按照分块一般的查询过程考虑贡献：

1. 散块内部的贡献：预处理出第 $i$ 块长为 $j$ 的前 / 后缀里的逆序对数，设为 $pre_{i, j}$ 和 $suf_{i, j}$，这部分写个树状数组可以做到 $O(n \log n)$。

2. 整块间的贡献：考虑预处理出 $i \sim j$ 块的逆序对数 $A_{i, j}$，但是这个怎么求呢：考虑容斥，$A_{i, j} = A_{i, j - 1} + A_{i + 1, j} - A_{i + 1, j - 1} + calc(i, j)$，其中 $calc(i, j)$ 表示第 $j$ 块对第 $i$ 块的贡献，注意到这个是可以先对每个块排序，再 $O(\dfrac{n^2}{B})$ 归并暴力预处理的，设为 $B_{i, j}$，于是也就可以递推算 $A_{i, j}$ 了。
3. 整块对散块的贡献：考虑预处理出从第 $1$ 块到第 $i$ 块有多少 $\gt x$ 的数，显然这个也是可以 $O(\dfrac{n^2}{B})$ 求出的，所以这部分贡献就可以求了。
4. 散块对散块的贡献：考虑把两个排好序的块拿出来归并，判掉不在查询区间里的数就行了，复杂度为 $O(B)$。

于是我们就解决了询问左右端点不在同一块的情况，再考虑同块的情况，这个可以类比 2 的容斥：设这一块的区间是 $[L, R]$，询问区间是 $[l, r] \subsetneq [L, R]$，子区间 $[i, j]$ 的答案是 $res_{i, j}$，则 $res_{L, R} = res_{l, R} + res_{L, r} - res_{l, r} + Calc([L, l - 1], [r + 1, R])$，其中 $Calc(I_1, I_2)$ 表示区间 $I_2$ 对区间 $I_1$ 的贡献，注意到$res_{L, R}$，$res_{l, R}$ 和 $res_{L, r}$ 都是 1 里已经处理出的前后缀信息，而 $Calc$ 可以在 $O(B)$ 时间内归并完成，于是移项就可以求出 $res_{l, r}$ 了，复杂度为 $O(B)$。

于是最终的复杂度为 $O(\dfrac{n^2}{B} + qB)$，平衡后得到 $O(n\sqrt{q})$，$B = O(\dfrac{n}{\sqrt{q}})$。

~~那么这道题卡不卡常呢，好难猜啊~~

